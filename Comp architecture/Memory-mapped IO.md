![[Pasted image 20221130114230.png]]
Memory-mapped I/O uses the same [address space](https://en.wikipedia.org/wiki/Address_space "Address space") to address both [main memory](https://en.wikipedia.org/wiki/Main_memory "Main memory") and [I/O devices](https://en.wikipedia.org/wiki/I/O_device "I/O device"). The memory and [registers](https://en.wikipedia.org/wiki/Register_(computing) "Register (computing)") of the I/O devices are mapped to (associated with) address values. So a memory address may refer to either a portion of [physical RAM](https://en.wikipedia.org/wiki/Physical_memory "Physical memory"), or instead to memory and registers of the I/O device. Thus, the CPU instructions used to access the memory can also be used for accessing devices. Each I/O device monitors the CPU's address bus and responds to any CPU access of an address assigned to that device, connecting the [data bus](https://en.wikipedia.org/wiki/Bus_(computing) "Bus (computing)") to the desired device's [hardware register](https://en.wikipedia.org/wiki/Hardware_register "Hardware register"). To accommodate the I/O devices, some areas of the address bus used by the CPU must be reserved for I/O and must not be available for normal physical memory. The reservation may be permanent, or temporary (as achieved via [bank switching](https://en.wikipedia.org/wiki/Bank_switching "Bank switching")). An example of the latter is found in the [Commodore 64](https://en.wikipedia.org/wiki/Commodore_64 "Commodore 64"), which uses a form of memory mapping to cause [RAM](https://en.wikipedia.org/wiki/Random-access_memory "Random-access memory") or I/O hardware to appear in the `0xD000-0xDFFF` range.